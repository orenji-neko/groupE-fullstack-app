{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\nimport { Role } from '@app/_models';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/_services\";\n// array in local storage for accounts\nconst accountsKey = 'angular-10-registration-login-example-accounts';\nlet accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    constructor(alertService) {\n      this.alertService = alertService;\n    }\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      const alertService = this.alertService;\n      return handleRoute();\n      function handleRoute() {\n        switch (true) {\n          case url.endsWith('/accounts/authenticate') && method === 'POST':\n            return authenticate();\n          case url.endsWith('/accounts/refresh-token') && method === 'POST':\n            return refreshToken();\n          case url.endsWith('/accounts/revoke-token') && method === 'POST':\n            return revokeToken();\n          case url.endsWith('/accounts/register') && method === 'POST':\n            return register();\n          case url.endsWith('/accounts/verify-email') && method === 'POST':\n            return verifyEmail();\n          case url.endsWith('/accounts/forgot-password') && method === 'POST':\n            return forgotPassword();\n          case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\n            return validateResetToken();\n          case url.endsWith('/accounts/reset-password') && method === 'POST':\n            return resetPassword();\n          case url.endsWith('/accounts') && method === 'GET':\n            return getAccounts();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'GET':\n            return getAccountById();\n          case url.endsWith('/accounts') && method === 'POST':\n            return createAccount();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\n            return updateAccount();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'DELETE':\n            return deleteAccount();\n          default:\n            // pass through any requests not handled above\n            return next.handle(request);\n        }\n      }\n      // route functions\n      function authenticate() {\n        const {\n          email,\n          password\n        } = body;\n        const account = accounts.find(x => x.email === email);\n        if (!account) {\n          return error('Email does not exist');\n        }\n        if (!account.isVerified) {\n          // Display verification email alert\n          setTimeout(() => {\n            const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n            alertService.info(`\n                        <h4>Verification Email</h4>\n                        <p>Please click the below link to verify your email address:</p>\n                        <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                    `, {\n              autoClose: false\n            });\n          }, 1000);\n          return error('Email is not yet verified');\n        }\n        if (account.password !== password) {\n          return error('Incorrect password');\n        }\n        if (account.status !== 'Active') {\n          return error('Account is inactive. Please contact support.');\n        }\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(Object.assign(Object.assign({}, basicDetails(account)), {\n          jwtToken: generateJwtToken(account)\n        }));\n      }\n      function refreshToken() {\n        const refreshToken = getRefreshToken();\n        if (!refreshToken) return unauthorized();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        if (!account) return unauthorized();\n        // replace old refresh token with a new one and save\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(Object.assign(Object.assign({}, basicDetails(account)), {\n          jwtToken: generateJwtToken(account)\n        }));\n      }\n      function revokeToken() {\n        if (!isAuthenticated()) return unauthorized();\n        const refreshToken = getRefreshToken();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        // revoke token and save\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function register() {\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) {\n          // display email already registered message in alert\n          setTimeout(() => {\n            alertService.info(`\n                        <h4>Email Already Registered</h4>\n                        <p>Your email ${account.email} is already registered.</p>\n                        <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\n                        <div>\n                        <strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.\n                        </div>\n                    `, {\n              autoclose: false\n            });\n          }, 1000);\n          // always return ok() response to prevent email enumeration\n          return ok();\n        }\n        // assign account id and a few other properties then save\n        account.id = newAccountId();\n        if (account.id === 1) {\n          // first registered account is an admin\n          account.role = Role.Admin;\n          account.status = 'Active'; // Admin accounts get active status\n        } else {\n          account.role = Role.User;\n          account.status = 'Inactive'; // User accounts get inacitve status upon creation\n        }\n\n        account.dateCreated = new Date().toISOString();\n        account.verificationToken = new Date().getTime().toString();\n        account.isVerified = false;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // display verification email in alert\n        setTimeout(() => {\n          const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n          alertService.info(`\n                    <h4>Verification Email</h4>\n                    <p>Thanks for registering!</p>\n                    <p>Please click the below link to verify your email address:</p>\n                    <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\n                `, {\n            autoclose: false\n          });\n        }, 1000);\n        return ok();\n      }\n      function verifyEmail() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => !!x.verificationToken && x.verificationToken === token);\n        if (!account) return error('Verification failed');\n        // set is verified flag to true if token is valid\n        account.isVerified = true;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function forgotPassword() {\n        const {\n          email\n        } = body;\n        const account = accounts.find(x => x.email === email);\n        // always return ok() response to prevent email enumeration\n        if (!account) return ok();\n        // create reset token that expires after 24 hours\n        account.resetToken = new Date().getTime().toString();\n        account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // display password reset email in alert\n        setTimeout(() => {\n          const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\n          alertService.info(`\n                    <h4>Reset Password Email</h4>\n                    <p>Please click the below link to reset your password, the link will be valid for 1 day:</p>\n                    <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\n                `, {\n            autoClose: false\n          });\n        }, 1000);\n        return ok();\n      }\n      function validateResetToken() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error(\"Invalid token\");\n        return ok();\n      }\n      function resetPassword() {\n        const {\n          token,\n          password\n        } = body;\n        const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error('Invalid token');\n        // update password and remove reset token\n        account.password = password;\n        account.isVerified = true;\n        delete account.resetToken;\n        delete account.resetTokenExpires;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function getAccounts() {\n        if (!isAuthenticated()) return unauthorized();\n        return ok(accounts.map(x => basicDetails(x)));\n      }\n      function getAccountById() {\n        if (!isAuthenticated()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl());\n        // user accounts can get own profile and admin accounts can get all profiles\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        return ok(basicDetails(account));\n      }\n      function createAccount() {\n        if (!isAuthorized(Role.Admin)) return unauthorized();\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) {\n          return error(`Email ${account.email} is already registered`);\n        }\n        // assign account id and a few other properties then save\n        account.id = newAccountId();\n        account.status = 'Inactive';\n        account.dateCreated = new Date().toISOString();\n        account.isVerified = true;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function updateAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        let params = body;\n        let account = accounts.find(x => x.id == idFromUrl());\n        // user accounts can update own profile and admin accounts can update all profiles\n        if (account.id != currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        // only update password if included\n        if (!params.password) {\n          delete params.password;\n        }\n        // don't save confirm password\n        delete params.confirmPassword;\n        // update and save account\n        Object.assign(account, params);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(basicDetails(account));\n      }\n      function deleteAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl());\n        // user accounts can delete own account and admin accounts can delete any account\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        // delete account then save\n        accounts = accounts.filter(x => x.id !== idFromUrl());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      // helper functions\n      function ok(body) {\n        return of(new HttpResponse({\n          status: 200,\n          body\n        })).pipe(delay(500)); // delay observable to simulate server api call\n      }\n\n      function error(message) {\n        return throwError({\n          error: {\n            message\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n        // call materialize and dematerialize to ensure delay even if an error is thrown\n      }\n\n      function unauthorized() {\n        return throwError({\n          status: 401,\n          error: {\n            message: 'Unauthorized'\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n      }\n      function basicDetails(account) {\n        const {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified,\n          status\n        } = account;\n        return {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified,\n          status\n        };\n      }\n      function isAuthenticated() {\n        return !!currentAccount();\n      }\n      function isAuthorized(role) {\n        const account = currentAccount();\n        if (!account) return false;\n        return account.role === role;\n      }\n      function idFromUrl() {\n        const urlParts = url.split('/');\n        return parseInt(urlParts[urlParts.length - 1]);\n      }\n      function newAccountId() {\n        return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\n      }\n      function currentAccount() {\n        // check if jwt token is in auth header\n        const authHeader = headers.get('Authorization');\n        if (!authHeader || !authHeader.startsWith('Bearer fake-jwt-token')) return;\n        // check if token is expired\n        const jwtToken = JSON.parse(atob(authHeader.split('.')[1]));\n        const tokenExpired = Date.now() > jwtToken.exp * 1000;\n        if (tokenExpired) return;\n        const account = accounts.find(x => x.id === jwtToken.id);\n        return account;\n      }\n      function generateJwtToken(account) {\n        // create token that expires in 15 minutes\n        const tokenPayload = {\n          exp: Math.round(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000),\n          id: account.id\n        };\n        return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\n      }\n      function generateRefreshToken() {\n        const token = new Date().getTime().toString();\n        // add token cookie that expires in 7 days\n        const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString();\n        document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/`;\n        return token;\n      }\n      function getRefreshToken() {\n        // get refresh token from cookie\n        return (document.cookie.split(';').find(x => x.includes('fakeRefreshToken')) || '=').split('=')[1];\n      }\n    }\n  }\n  FakeBackendInterceptor.ɵfac = function FakeBackendInterceptor_Factory(t) {\n    return new (t || FakeBackendInterceptor)(i0.ɵɵinject(i1.AlertService));\n  };\n  FakeBackendInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FakeBackendInterceptor,\n    factory: FakeBackendInterceptor.ɵfac\n  });\n  return FakeBackendInterceptor;\n})();\nexport let fakeBackendProvider = {\n  // use fake backend in place of Http service for backend-less development\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":{"version":3,"mappings":"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","names":["HttpResponse","HTTP_INTERCEPTORS","of","throwError","delay","materialize","dematerialize","Role","accountsKey","accounts","JSON","parse","localStorage","getItem","FakeBackendInterceptor","constructor","alertService","intercept","request","next","url","method","headers","body","handleRoute","endsWith","authenticate","refreshToken","revokeToken","register","verifyEmail","forgotPassword","validateResetToken","resetPassword","getAccounts","match","getAccountById","createAccount","updateAccount","deleteAccount","handle","email","password","account","find","x","error","isVerified","setTimeout","verifyUrl","location","origin","verificationToken","info","autoClose","status","refreshTokens","push","generateRefreshToken","setItem","stringify","ok","basicDetails","jwtToken","generateJwtToken","getRefreshToken","unauthorized","includes","filter","isAuthenticated","autoclose","id","newAccountId","role","Admin","User","dateCreated","Date","toISOString","getTime","toString","confirmPassword","token","resetToken","resetTokenExpires","now","resetUrl","map","idFromUrl","currentAccount","isAuthorized","params","Object","assign","pipe","message","title","firstName","lastName","urlParts","split","parseInt","length","Math","max","authHeader","get","startsWith","atob","tokenExpired","exp","tokenPayload","round","btoa","expires","toUTCString","document","cookie","factory","fakeBackendProvider","provide","useClass","multi"],"sourceRoot":"","sources":["D:\\user-management-system\\client\\src\\app\\_helpers\\fake-backend.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpRequest, HttpResponse, HttpHandler, HttpEvent, HttpInterceptor, HTTP_INTERCEPTORS, HttpHeaders } from '@angular/common/http';\r\nimport { Observable, of, throwError } from 'rxjs';\r\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\r\n\r\nimport { AlertService } from '@app/_services';\r\nimport { Role } from '@app/_models';\r\n\r\n// array in local storage for accounts\r\nconst accountsKey = 'angular-10-registration-login-example-accounts';\r\nlet accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\r\n\r\n@Injectable()\r\nexport class FakeBackendInterceptor implements HttpInterceptor {\r\n    constructor(private alertService: AlertService) { }\r\n\r\n    intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\r\n        const { url, method, headers, body } = request;\r\n        const alertService = this.alertService;\r\n\r\n        return handleRoute();\r\n\r\n        function handleRoute() {\r\n            switch (true) {\r\n                case url.endsWith('/accounts/authenticate') && method === 'POST':\r\n                    return authenticate();\r\n                case url.endsWith('/accounts/refresh-token') && method === 'POST':\r\n                    return refreshToken();\r\n                case url.endsWith('/accounts/revoke-token') && method === 'POST':\r\n                    return revokeToken();\r\n                case url.endsWith('/accounts/register') && method === 'POST':\r\n                    return register();\r\n                case url.endsWith('/accounts/verify-email') && method === 'POST':\r\n                    return verifyEmail();\r\n                case url.endsWith('/accounts/forgot-password') && method === 'POST':\r\n                    return forgotPassword();\r\n                case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\r\n                    return validateResetToken();\r\n                case url.endsWith('/accounts/reset-password') && method === 'POST':\r\n                    return resetPassword();\r\n                case url.endsWith('/accounts') && method === 'GET':\r\n                    return getAccounts();\r\n                case url.match(/\\/accounts\\/\\d+$/) && method === 'GET':\r\n                    return getAccountById();\r\n                case url.endsWith('/accounts') && method === 'POST':\r\n                    return createAccount();\r\n                case url.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\r\n                    return updateAccount();\r\n                case url.match(/\\/accounts\\/\\d+$/) && method === 'DELETE':\r\n                    return deleteAccount();\r\n                default:\r\n                    // pass through any requests not handled above\r\n                    return next.handle(request);\r\n            }\r\n        }\r\n\r\n        // route functions\r\n        function authenticate() {\r\n            const { email, password } = body;\r\n            const account = accounts.find(x => x.email === email);\r\n        \r\n            if (!account) {\r\n                return error('Email does not exist');\r\n            }\r\n        \r\n            if (!account.isVerified) {\r\n                // Display verification email alert\r\n                setTimeout(() => {\r\n                    const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\r\n                    alertService.info(`\r\n                        <h4>Verification Email</h4>\r\n                        <p>Please click the below link to verify your email address:</p>\r\n                        <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\r\n                    `, { autoClose: false });\r\n                }, 1000);\r\n        \r\n                return error('Email is not yet verified');\r\n            }\r\n        \r\n            if (account.password !== password) {\r\n                return error('Incorrect password');\r\n            }\r\n        \r\n            if (account.status !== 'Active') {\r\n                return error('Account is inactive. Please contact support.');\r\n            }\r\n        \r\n            account.refreshTokens.push(generateRefreshToken());\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n        \r\n            return ok({\r\n                ...basicDetails(account),\r\n                jwtToken: generateJwtToken(account)\r\n            });\r\n        }\r\n        \r\n        \r\n\r\n        function refreshToken() {\r\n            const refreshToken = getRefreshToken();\r\n\r\n            if (!refreshToken) return unauthorized();\r\n\r\n            const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\r\n\r\n            if (!account) return unauthorized();\r\n\r\n            // replace old refresh token with a new one and save\r\n            account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\r\n            account.refreshTokens.push(generateRefreshToken());\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok({\r\n                ...basicDetails(account),\r\n                jwtToken: generateJwtToken(account)\r\n            });\r\n        }\r\n\r\n        function revokeToken() {\r\n            if (!isAuthenticated()) return unauthorized();\r\n\r\n            const refreshToken = getRefreshToken();\r\n            const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\r\n\r\n            // revoke token and save\r\n            account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok();\r\n        }\r\n\r\n        function register() {\r\n            const account = body;\r\n\r\n            if (accounts.find(x => x.email === account.email)) {\r\n                // display email already registered message in alert\r\n                setTimeout(() => {\r\n                    alertService.info(`\r\n                        <h4>Email Already Registered</h4>\r\n                        <p>Your email ${account.email} is already registered.</p>\r\n                        <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\r\n                        <div>\r\n                        <strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.\r\n                        </div>\r\n                    `, { autoclose: false });\r\n                }, 1000);\r\n\r\n                // always return ok() response to prevent email enumeration\r\n                return ok();\r\n            }\r\n\r\n            // assign account id and a few other properties then save\r\n            account.id = newAccountId();\r\n            if (account.id === 1) {\r\n                // first registered account is an admin\r\n                account.role = Role.Admin;\r\n                account.status = 'Active'; // Admin accounts get active status\r\n            } else {\r\n                account.role = Role.User;\r\n                account.status = 'Inactive'; // User accounts get inacitve status upon creation\r\n            }\r\n            account.dateCreated = new Date().toISOString();\r\n            account.verificationToken = new Date().getTime().toString();\r\n            account.isVerified = false;\r\n            account.refreshTokens = [];\r\n            delete account.confirmPassword;\r\n            accounts.push(account);\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            // display verification email in alert\r\n            setTimeout(() => {\r\n                const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\r\n                alertService.info(`\r\n                    <h4>Verification Email</h4>\r\n                    <p>Thanks for registering!</p>\r\n                    <p>Please click the below link to verify your email address:</p>\r\n                    <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\r\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\r\n                `, { autoclose: false });\r\n            }, 1000);\r\n\r\n            return ok();\r\n        }\r\n\r\n        function verifyEmail() {\r\n            const { token } = body;\r\n            const account = accounts.find(x => !!x.verificationToken && x.verificationToken === token);\r\n\r\n            if (!account) return error('Verification failed');\r\n\r\n            // set is verified flag to true if token is valid\r\n            account.isVerified = true;\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok();\r\n        }\r\n\r\n        function forgotPassword() {\r\n            const { email } = body;\r\n            const account = accounts.find(x => x.email === email);\r\n\r\n            // always return ok() response to prevent email enumeration\r\n            if (!account) return ok();\r\n\r\n            // create reset token that expires after 24 hours\r\n            account.resetToken = new Date().getTime().toString();\r\n            account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            // display password reset email in alert\r\n            setTimeout(() => {\r\n                const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\r\n                alertService.info(`\r\n                    <h4>Reset Password Email</h4>\r\n                    <p>Please click the below link to reset your password, the link will be valid for 1 day:</p>\r\n                    <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\r\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\r\n                `, { autoClose: false });\r\n            }, 1000);\r\n\r\n            return ok();\r\n        }\r\n\r\n        function validateResetToken() {\r\n            const { token } = body;\r\n            const account = accounts.find(x =>\r\n                !!x.resetToken &&\r\n                x.resetToken === token &&\r\n                new Date() < new Date(x.resetTokenExpires)\r\n            );\r\n\r\n            if (!account) return error(\"Invalid token\");\r\n\r\n            return ok();\r\n        }\r\n\r\n        function resetPassword() {\r\n            const { token, password } = body;\r\n            const account = accounts.find(x =>\r\n                !!x.resetToken && x.resetToken === token &&\r\n                new Date() < new Date(x.resetTokenExpires)\r\n            );\r\n\r\n            if (!account) return error('Invalid token');\r\n\r\n            // update password and remove reset token\r\n            account.password = password;\r\n            account.isVerified = true;\r\n            delete account.resetToken;\r\n            delete account.resetTokenExpires;\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok();\r\n        }\r\n\r\n        function getAccounts() {\r\n            if (!isAuthenticated()) return unauthorized();\r\n            return ok(accounts.map(x => basicDetails(x)));\r\n        }\r\n\r\n        function getAccountById() {\r\n            if (!isAuthenticated()) return unauthorized();\r\n\r\n            let account = accounts.find(x => x.id === idFromUrl());\r\n\r\n            // user accounts can get own profile and admin accounts can get all profiles\r\n            if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\r\n                return unauthorized();\r\n            }\r\n\r\n            return ok(basicDetails(account));\r\n\r\n        }\r\n\r\n        function createAccount() {\r\n            if (!isAuthorized(Role.Admin)) return unauthorized();\r\n\r\n            const account = body;\r\n            if (accounts.find(x => x.email === account.email)) {\r\n                return error(`Email ${account.email} is already registered`);\r\n            }\r\n\r\n            // assign account id and a few other properties then save\r\n            account.id = newAccountId();\r\n            account.status = 'Inactive';\r\n            account.dateCreated = new Date().toISOString();\r\n            account.isVerified = true;\r\n            account.refreshTokens = [];\r\n            delete account.confirmPassword;\r\n            accounts.push(account);\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok();\r\n        }\r\n\r\n        function updateAccount() {\r\n            if (!isAuthenticated()) return unauthorized();\r\n\r\n            let params = body;\r\n            let account = accounts.find(x => x.id == idFromUrl());\r\n\r\n            // user accounts can update own profile and admin accounts can update all profiles\r\n            if (account.id != currentAccount().id && !isAuthorized(Role.Admin)) {\r\n                return unauthorized();\r\n            }\r\n\r\n            // only update password if included\r\n            if (!params.password) {\r\n                delete params.password;\r\n            }\r\n            // don't save confirm password\r\n            delete params.confirmPassword;\r\n\r\n            // update and save account\r\n            Object.assign(account, params);\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok(basicDetails(account));\r\n        }\r\n\r\n        function deleteAccount() {\r\n            if (!isAuthenticated()) return unauthorized();\r\n\r\n            let account = accounts.find(x => x.id === idFromUrl());\r\n\r\n            // user accounts can delete own account and admin accounts can delete any account\r\n            if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\r\n                return unauthorized();\r\n            }\r\n\r\n            // delete account then save\r\n            accounts = accounts.filter(x => x.id !== idFromUrl());\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok();\r\n        }\r\n\r\n        // helper functions\r\n        function ok(body?) {\r\n            return of(new HttpResponse({ status: 200, body }))\r\n                .pipe(delay(500)); // delay observable to simulate server api call\r\n        }\r\n\r\n        function error(message) {\r\n            return throwError({ error: { message } })\r\n                .pipe(materialize(), delay(500), dematerialize());\r\n            // call materialize and dematerialize to ensure delay even if an error is thrown\r\n        }\r\n\r\n        function unauthorized() {\r\n            return throwError({ status: 401, error: { message: 'Unauthorized' } })\r\n                .pipe(materialize(), delay(500), dematerialize());\r\n        }\r\n\r\n        function basicDetails(account) {\r\n            const { id, title, firstName, lastName, email, role, dateCreated, isVerified, status } = account;\r\n            return { id, title, firstName, lastName, email, role, dateCreated, isVerified, status };\r\n        }\r\n        \r\n\r\n        function isAuthenticated() {\r\n            return !!currentAccount();\r\n        }\r\n\r\n        function isAuthorized(role) {\r\n            const account = currentAccount();\r\n            if (!account) return false;\r\n            return account.role === role;\r\n        }\r\n\r\n        function idFromUrl() {\r\n            const urlParts = url.split('/');\r\n            return parseInt(urlParts[urlParts.length - 1]);\r\n        }\r\n\r\n        function newAccountId() {\r\n            return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\r\n        }\r\n\r\n        function currentAccount() {\r\n            // check if jwt token is in auth header\r\n            const authHeader = headers.get('Authorization');\r\n            if (!authHeader || !authHeader.startsWith('Bearer fake-jwt-token')) return;\r\n\r\n            // check if token is expired\r\n            const jwtToken = JSON.parse(atob(authHeader.split('.')[1]));\r\n            const tokenExpired = Date.now() > (jwtToken.exp * 1000);\r\n            if (tokenExpired) return;\r\n\r\n            const account = accounts.find(x => x.id === jwtToken.id);\r\n            return account;\r\n        }\r\n\r\n        function generateJwtToken(account) {\r\n            // create token that expires in 15 minutes\r\n            const tokenPayload = {\r\n                exp: Math.round(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000),\r\n                id: account.id\r\n            };\r\n            return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\r\n        }\r\n\r\n        function generateRefreshToken() {\r\n            const token = new Date().getTime().toString();\r\n\r\n            // add token cookie that expires in 7 days\r\n            const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString();\r\n            document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/`;\r\n            return token;\r\n        }\r\n\r\n        function getRefreshToken() {\r\n            // get refresh token from cookie\r\n            return (document.cookie.split(';').find(x => x.includes('fakeRefreshToken')) || '=').split('=')[1];\r\n        }\r\n    }\r\n}\r\n\r\nexport let fakeBackendProvider = {\r\n    // use fake backend in place of Http service for backend-less development\r\n    provide: HTTP_INTERCEPTORS,\r\n    useClass: FakeBackendInterceptor,\r\n    multi: true\r\n};"]},"metadata":{},"sourceType":"module","externalDependencies":[]}